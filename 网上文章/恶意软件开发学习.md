### 恶意软件开发学习

#### 前言

 随着时间的推移，我们看到越来越多的人提出合理的问题——如何进入恶意软件开发领域？暂且不论道德问题，因为我相信有些人会质疑这些人是红队成员、轻度好奇者，还是想成为威胁行为者的人。我想我们应该深入探讨一下，解释学习恶意软件开发所需的路径。在开始之前，我会简要讲述我个人是如何进入恶意软件开发领域的。

---

#### 第一部分  
**我的故事：我不擅长编程。我学得很慢。预期会失败。**

---

在2000年代初的某个时候，我非常喜欢电子游戏。我玩了一款叫《光环2》的游戏。在《光环2》中，经常会遇到一些通过DDoS攻击作弊的人。当我遇到这种情况时，我感到非常惊讶。我从未想过有人会滥用计算机来谋取利益或个人收益。我立刻被吸引，并开始了我的恶意软件之旅。不幸的是，由于当时我还年轻，我遇到了很多骗子或只会用脚本的小白。最初我完全不知道自己在做什么，可能更多的是伤害了自己。但我认为这些都是成长的痛苦。在那个时期，StackOverflow还不存在——我依靠一些奇怪的论坛和IRC从互联网上的陌生人那里学习信息。随着我探索的深入，恶意软件似乎像黑魔法一样——没有文档或讨论。这进一步激发了我的好奇心。最终，我从EFNET上的某个人那里得到了一些很好的建议——我必须学会编程。于是我买了《C Primer Plus》（一本很棒的书），并从头到尾读了一遍。读完这本书后，我擅长编程了吗？没有。我理解恶意软件了吗？也没有。我学会了C语言的基础，但对这门语言的理解还不够。有人告诉我，我需要完成一些编程项目，才能有足够的技能进入恶意软件开发领域。我的第一个C程序非常无聊——计算各种数学问题。后来我尝试扩展，试图连接到Dictionary.com，并尝试用C语言获取单词的定义。我还尝试了其他各种项目，但都失败了，而且失败得很惨。事实上，我在4年内都没有达到足够的C编程水平。我花了很多时间被学校、女孩和电子游戏分心。我是个青少年，不够专注。恶意软件和C编程需要我无法集中的专注力。人们通常不会告诉你的是，刚开始编程时是很痛苦的——学习编程非常无聊。但一旦你掌握了它，你可以连续编程几个小时，而不会注意到时间的流逝。经过4年的失败，我终于达到了理解恶意软件的水平。我发现了一个叫VxHeaven和Rohitab的网站。这些网站加速了我的恶意软件开发能力，那是我年轻时的一段美好时光。

现在，让我们快进几年……在我20岁出头的时候，我找到了一份软件工程师的工作（尽管我没有学位）。我是初级软件工程师。大约2年后，我升到了中级软件工程师，再过几年，我成为了高级软件工程师。我在一家中型到大型公司工作。我的经验和专业知识让我主导开发，我与Scrum Master讨论冲刺主题，帮助经验不足的工程师，并承担了许多其他职责。我通过学习如何开发恶意软件获得了这些工作。今天，截至撰写本文时，我掌握了C、C++、C#、VB.NET、Microsoft T-SQL、JavaScript、Python、AutoIT和x86汇编语言。虽然我可以用所有这些语言编写代码，但我的强项是C/C++、T-SQL和C#.NET。

总结一下，这段自传的重点是，每个人的恶意软件开发之旅都不同。有些人学得很快，表现出色，而另一些人（比如我）则经常失败——但坚持是必要的。如果你在恶意软件开发中失败了，如果你在学习中遇到困难，如果有些事情对你来说没有意义，不要灰心。这是一个严肃的主题，一个完整的职业领域，与软件工程、逆向工程，甚至在某些情况下与网络工程重叠（***取决于你想做什么，例如FastFLUX和DGA）。

---

#### 第二部分  
**学会编程。预期会失败。**

---

首先，必须明确指出，编程是绝对必要的。我们看到有人问编程是否是必需的。这个问题很荒谬——这是恶意软件（malware...），所以编程是基本要求。其次，你必须擅长或至少半擅长编程。确实，我们看到很多非常糟糕的恶意软件，以及泄露的恶意软件源代码，但归根结底，恶意软件开发可以最好地描述为一种替代形式的合法低级Windows软件工程——（***或Linux，或MacOS，或你选择的任何操作系统）。

如果你的目标是编写恶意软件，但你还不会编程，建议你放弃恶意软件开发的想法，先去学习编程。建议你不要浪费时间在x1000个不同的平台中选择学习编程的平台，只需选择一个并开始学习。我们看到很多人问“我在哪里可以最好地学习？”，但最终这反映了他们的犹豫或拖延，这甚至不应该是一个真正的问题。找一本关于你想学习的编程语言的书，从头到尾读完，然后开始编程。没有捷径，没有轻松的道路，这是绝对必要的。随着恶意软件开发变得越来越复杂，它已经成为了软件工程。大规模的威胁行为者会有冲刺、已知问题和任何其他软件套件可能遇到的工程挑战。因此，总结一下，学会编程。其他声称会编程的人（我们非常怀疑）会问关于恶意软件技术的问题。在我们深入探讨这个子话题之前，重要的是要注意，任何对低级编程有足够理解的人都已经理解了恶意软件的基本概念——就像一个有足够天赋的低级程序员理解漏洞开发的基础一样。当然，这并不意味着他们理解细节或内部机制，但他们已经有了扎实的入门知识。

为什么我们说真正有天赋的程序员已经理解了恶意软件开发的基础？我们这么说是因为恶意软件最简单的形式就是滥用合法的API来实现恶意目的。为了说明这一点，我们举一个简单的例子。在Windows操作系统中，有一个名为“GetAsyncKeyState”的函数。GetAsyncKeyState用于确定在调用函数时某个键（在键盘上）是按下还是松开，以及该键是否在上一次调用GetAsyncKeyState后被按下。这个函数被键盘记录器使用。它已经被用于键盘记录器很长时间了。这个函数允许个人确定键盘上的某个键何时被按下。为什么这个函数存在，如果它可能被用于键盘记录器？答案很简单——它可以用于合法目的。应用程序可能选择监控特定的快捷键。应用程序可能监控CTRL+C和CTRL+V（复制粘贴），或者某个应用程序可能创建一个内部特定的快捷键（例如Chrome浏览器的CTRL+T，用于创建新标签页）。确定是否使用了这些组合键的一种方法是使用这个API调用（GetAsyncKeyState）。以下是StackOverflow上的例子：

开发基本视频游戏的人：https://stackoverflow.com/questions/70164289/is-there-a-way-to-detect-when-a-key-is-pressed-only-once-not-held-down  
关于监控输入的基本问题：https://stackoverflow.com/questions/41600981/how-do-i-check-if-a-key-is-pressed-on-c  
YouTuber使用GetAsyncKeyState进行视频游戏开发：https://www.youtube.com/watch?v=AwD5vmzDDKo

当然，上面给出的例子，用于确定是否按下了快捷键，可以通过许多其他方式解决。这是一个简单的例子，说明了为什么存在通常被恶意软件使用的API。我们可以举出数百个……甚至数千个……例子，说明合法功能也可以被用于恶意软件开发。tl;dr 这是一个恶意软件开发与合法软件工程重叠的例子。

---

#### 第三部分  
**编写恶意软件。做事情。**

---

可以理解的是，许多新读者可能正在寻找学习恶意软件开发的坚实路径。现实情况是，每个人都有不同的路径和不同的兴趣点。我们鼓励新读者去探索，并且要大量探索。如果你喜欢Python，学习它是如何工作的，直到PVM。如果你喜欢在Windows上使用C编程，探索WINAPI并尝试完成一些基本任务。探索、学习并失败。如果你卡住了，或者不知道从哪里开始，继续探索。阅读恶意软件研究论文，阅读关于恶意软件的新闻，阅读关于APT或勒索软件组织的报道。探索并跟随你的好奇心。不要害怕问愚蠢的问题，不要害怕失败。

我们喜欢的资源（重点是Windows恶意软件）：

1. **vx-underground** - https://vx-underground.org - 这是我们的。可能有偏见，我不知道。
2. **BleepingComputer** - https://www.bleepingcomputer.com/ - 保持对新闻的关注。
3. **Mitre Attack for Windows** - https://attack.mitre.org/matrices/enterprise/windows/ - 攻击方法的综合列表。适合探索。
4. **Vergilius Project** - https://www.vergiliusproject.com/ - 关于Windows内部变化的良好文档。
5. **ReactOS** - https://reactos.org/ - 了解Windows内部工作原理的绝佳资源。
6. **The Old New Thing** - https://devblogs.microsoft.com/oldnewthing/author/oldnewthing - 不寻常的Windows内部、笔记和文档。
7. **Windows API Index** - https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list - 探索Windows允许你做什么。
8. **Malpedia** - https://malpedia.caad.fkie.fraunhofer.de/ - 识别恶意软件的资源。
9. **vx-underground恶意软件源代码集合** - https://github.com/vxunderground/MalwareSourceCode - 查看其他人的恶意软件代码。
10. **UnknownCheats** - https://www.unknowncheats.me - 游戏作弊论坛，关于Windows内部的优秀且不寻常的讨论。
11. **Geoff Chappell** - https://www.geoffchappell.com/index.htm - Windows内部解释的优秀来源。

可以列出更多资源，但这些是很好的概述网站，可以轻松引导你深入学习和探索。最后，在结束本节时，我们还有一些其他常见问题需要解答。

**Q - “我应该阅读《Windows Internals》第1卷和第2卷吗？”**  
A - 不，不要伤害自己。《Windows Internals》是一本很棒的书，但它非常技术性，很难坐下来阅读。《Windows Internals》最好以小部分阅读或作为参考指南。例如，如果你曾经想知道Windows注册表的工作原理，可以参考《Windows Internals》。但如果你已经熟练掌握了C和C WINAPI，可以跳过《Windows Internals》的大部分内容。如果你想阅读《Windows Internals》，建议你先对Windows API有一定的了解。否则，阅读《Windows Internals》会非常无聊和痛苦。

**Q - “Malapi.io是一个好的参考吗？”**  
A - 不，它不是。虽然这个网站很有趣，但问题是Windows上的任何函数都可以用于恶意行为，同样，大多数“看似恶意”的函数也可能有合法用途。MalAPI可能会列出Windows API中的每个函数，因为恶意软件的整个核心就是滥用合法功能。这可以比作某人汇编了一份对人类有害的物品清单——什么东西可以伤害人？如果有足够的时间、精力或力量，任何东西都可以。你可以被勺子刺伤，被泰迪熊窒息，甚至被强迫吃卫生纸而窒息死亡。

**Q - “Sektor7 Institute的恶意软件课程好吗？值得吗？”**  
A - 还可以。上次审查时，我们会给它打7/10分。这可能适合那些对恶意软件有一定了解但仍缺乏大量基础知识的人。该课程还重点介绍了通过进程注入等方式执行有效负载的内容——但他们没有讨论恶意软件的其他部分……比如……实际的有效负载本身。然而，如前所述，该课程是在一年多前审查的。tl;dr 就其价格而言，还可以。

---

#### 第四部分  
**技能水平金字塔**

---

我喜欢将恶意软件开发的不同技能水平进行分类。真正有天赋的恶意软件作者，可能在前5%，非常罕见。因此，前5%。在这之上，我将其分类为VXer，是最顶尖的。

```
               .
              /=\\
             /VX \ \
            /=====\' \
           /TOP 5% \'' \
          /=========\ ' '\
         / SKILLED   \''   \
        /             \ ' '  \
       /===============\   ''  \
      /  SEMI SKILLED   \' ' ' ' \
     /                   \' ' '  ' \
    /=====================\' '   ' ' \
   /     BEGINNERS         \  '   ' /
  /                         \   ' /
 /                           \'  /
/=============================\/
```

**初学者** - 他们会编程，目前正在学习或理解各种恶意软件的TTP（战术、技术和程序）。他们通常会撰写关于已知或已建立的恶意软件技术的文章。这构成了大多数恶意软件开发者的群体。许多人在这里失去兴趣，或转向另一个主题，或不需要（或不想）扩展这一技能。

**半熟练者** - 这些人会编程，而且可能编程得很好。这些人理解各种恶意软件的TTP，但尚未找到自己的兴趣点。恶意软件开发有许多不同的主题和子主题。正如本文第二部分简要提到的，恶意软件可以用许多不同的语言编写，在不同的平台上运行。有些人擅长Linux恶意软件，专注于ELF文件格式。有些人专注于跨平台语言，如Java、Ruby或Perl，并利用它们的不寻常字符进行滥用或多态性。

**熟练者** - 这是一个在选择的领域中精通各种恶意软件TTP的人。他们花更多时间阅读文档，而不是实际编写代码。很少有人能达到这个技能水平。在这个阶段，找到他们尚未听说过的恶意软件技术变得越来越困难（在他们选择的子主题或领域中）。

**前5%** - 这些人正在进行新颖的研究。他们对现有的和潜在的恶意软件技术非常了解，并积极追求新的恶意软件方法和想法。

**VXer** - 前1%。这些人已经存在了很长、很长、很长时间。他们发表了许多新颖的研究论文。他们可以最好地描述为领域专家。这不是通过技能或智力实现的，而是通过时间实现的。这些人也非常专注于某个领域，他们的工作可能不是传统意义上的恶意软件。可能是软件工程、逆向工程等。个人认为，达到这个水平的极少数人包括Grzegorz Tworek、Hexacorn、Alex Ionescu、qKumba、29a/z0mbie、James Forshaw、gerhart_x、Jon Skeet和JonasLyk。请注意，这不是一个全面的列表，仅代表个人观点。这些人发表了惊人的研究，他们的工作继续激励着各个技能水平的人。

- **Grzegorz Tworek** - 不寻常的系统组件逆向工程和滥用。
- **Hexacorn** - 不寻常的系统组件逆向工程和滥用。
- **Alex Ionescu** - Windows内部的大师。
- **qKumba** - 30多年的恶意软件逆向工程经验。
- **29a/z0mbie** - 对恶意软件变形和多态性的深刻理解。
- **James Forshaw** - 对漏洞开发和研究的深刻理解。
- **gerhart_x** - 对Hyper-V和操作系统内部的深刻理解。
- **Jon Skeet** - C#和.NET框架的大师。
- **JonasLyk** - 对Windows内部和不寻常系统组件逆向工程及滥用的深刻理解。

---

#### 第五部分  
**总结**

---

学会编程。多谷歌搜索。多失败。多阅读。

-smelly__vx，2022年12月4日







### 吐槽

####  吐槽1.

---

我受够了看到恶意软件的概念验证（PoC）使用 WINAPI 函数的 ANSI 版本。请停止使用 ANSI 版本。  
如果你使用 ANSI 版本，你的代码可能在非英语国家无法按设计工作，并且会引入额外的钩子点（可能？）。

UTF-8 vs UTF-16: https://stackoverflow.com/questions/496321/utf-8-utf-16-and-utf-32

如果你查看任何以 `A` 结尾的 WINAPI 函数，例如 `ShellExecuteExA`、`CreateFileA` 等，它会使用 `MultiByteToWideChar`（或类似的函数）将 UTF-8 编码转换为 UTF-16 编码。

```
CreateFileA(...)
-------------->CreateFileW
-------------------------->RtlDosPathNameToNtPathName_U 
-------------------------->InitializeObjectAttributes (宏 lol)
-------------------------->NtCreateFile
-------------------------->
```

如果你要使用 `CreateFile`，为了引入哪怕是最小、最微小的改进，你也应该使用 `CreateFileW`（或者直接使用 `NtCreateFile`，并在你的代码库中从头开始重新实现 `CreateFileW`）。

因为 `CreateFileW` 不是系统调用，但通常会被各种安全软件钩住，所以最佳实践是尝试自定义实现你自己的 `CreateFileW`。既然我们讨论到这个话题，我们也可以讨论其他功能的重新实现。

许多常用的用户模式 API 调用通常会被钩住，重新实现这些调用可以帮助减少恶意软件的有效载荷可见性。

一些来自 Norton AV 的常见例子：

参考: https://samples.vx-underground.org/Papers/Windows/Evasion%20-%20Other/2020-12-31%20-%20Antivirus%20Artifacts%20III.pdf  
--- 片段 ---  
一些被钩住的函数：  
- `CreateFileW`  
- `WriteProcessMemory`  
- `HeapCreate`  
- `MapViewOfFile`  
- `WinExec`  
--- 片段结束 ---

直接重写这些函数，或者随便你怎么做，但如果你做对了，你可以从内存链表中删除 `KERNEL32` 和 `KERNELBASE`，让它更加隐蔽和隐秘。或者你也可以重新实现 `STDIO`（`msvcrt`，不管微软现在怎么称呼它），这样你也可以删除这个库。与其使用 `strncpy`，不如这样做：

```c
PWCHAR SecureStringCopyW(_Inout_ PWCHAR String1, _In_ LPCWSTR String2, _In_ SIZE_T Size)
{
    PWCHAR pChar = String1;

    while (Size-- && (*String1++ = *String2++) != '\0');

    return pChar;
}
```

................或者这样做：

```c
PWCHAR StringCopyW(_Inout_ PWCHAR String1, _In_ LPCWSTR String2)
{
    PWCHAR p = String1;

    while ((*p++ = *String2++) != 0);

    return String1;
}
```

................然后你也可以这样做：

```c
SIZE_T StringLengthW(_In_ LPCWSTR String)
{
    LPCWSTR String2;

    for (String2 = String; *String2; ++String2);

    return (String2 - String);
}

PWCHAR StringConcatW(_Inout_ PWCHAR String, _In_ LPCWSTR String2)
{
    StringCopyW(&String[StringLengthW(String)], String2);

    return String;
}
```

................然后你也可以这样做：

```c
INT StringCompareW(_In_ LPCWSTR String1, _In_ LPCWSTR String2)
{
    for (; *String1 == *String2; String1++, String2++)
    {
        if (*String1 == '\0')
            return 0;
    }

    return ((*(LPCWSTR)String1 < *(LPCWSTR)String2) ? -1 : +1);
}
```

................然后你可以做一个酷酷的家伙，这样做：

```c
BOOL RemoveDllFromPebW(_In_ LPCWSTR lpModuleName)
{
    PPEB Peb = GetPeb();
    PLDR_MODULE Module = NULL;

    PLIST_ENTRY Head = &Peb->LoaderData->InMemoryOrderModuleList;
    PLIST_ENTRY Next = Head->Flink;
    Module = (PLDR_MODULE)((PBYTE)Next - 16);

    while (Next != Head)
    {
        Module = (PLDR_MODULE)((PBYTE)Next - 16);
        if (Module->BaseDllName.Buffer != NULL)
        {
            if (StringCompareW(lpModuleName, Module->BaseDllName.Buffer) == 0)
            {
                RemoveEntryList(&Module->InLoadOrderModuleList);
                RemoveEntryList(&Module->InInitializationOrderModuleList);
                RemoveEntryList(&Module->InMemoryOrderModuleList);
                RemoveEntryList(&Module->HashTableEntry);

                return TRUE;
            }
        }
        Next = Next->Flink;
    }

    return FALSE;
}
```

直接删除 `msvcrt`，或者 `kernelbase`，或者 `kernel32`，随便你。

---

#### 吐槽 2.

---

不要两次遍历 `KERNEL32` 或 `KERNELBASE`。杀毒软件通常会插入 DLL 到加载的二进制文件中，所以不能确定 DLL 是第 3 个、第 5 个还是第 10000 个条目。检查映像 DLL 名称。

---

#### 吐槽 3.

---

有时候像 `CreateFileW` 和 `NtCreateFile` 这样的函数是明显的钩子目标，所以给杀毒软件/EDR 来个曲线球很有趣。`IEFRAME.DLL`（Internet Explorer 的 DLL）有它自己的 `CreateFileW` 实现。导入 `IECreateFileW` 来混淆一下。

```c
HANDLE IeCreateFileW(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)
{
    typedef HANDLE(WINAPI* IECREATEFILE)(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
    IECREATEFILE IeCreateFile = NULL;

    IeCreateFile = (IECREATEFILE)GetProcAddressA((DWORD64)TryLoadDllMultiMethodW((PWCHAR)L"ieframe.dll"), "IECreateFile");
    if (!IeCreateFile)
        return NULL;

    return IeCreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}
```

................Internet Explorer 有很多奇怪的东西被重新实现了。所以你可以代理各种函数，比如：

```c
BOOL IEGetFileAttributesExW(_In_ LPCWSTR lpFileName, _In_ GET_FILEEX_INFO_LEVELS fInfoLevelId, _Out_ LPVOID lpFileInformation)
{
    typedef BOOL(WINAPI* IEGETFILEATTRIBUTESEX)(LPCWSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
    IEGETFILEATTRIBUTESEX IeGetFileAttributesExW = NULL;

    IeGetFileAttributesExW = (IEGETFILEATTRIBUTESEX)GetProcAddressA((DWORD64)TryLoadDllMultiMethodW((PWCHAR)L"ieframe.dll"), "IEGetFileAttributesEx");
    if (!IeGetFileAttributesExW)
        return FALSE;

    return IeGetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation);
}
```

................或者

```c
BOOL IeCreateDirectoryW(_In_ LPCWSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    typedef BOOL(WINAPI* IECREATEDIRECTORY)(LPCWSTR, LPSECURITY_ATTRIBUTES);
    IECREATEDIRECTORY IECreateDirectory = NULL;

    IECreateDirectory = (IECREATEDIRECTORY)GetProcAddressA((DWORD64)TryLoadDllMultiMethodW((PWCHAR)L"ieframe.dll"), "IECreateDirectory");
    if (!IECreateDirectory)
        return FALSE;

    return IECreateDirectory(lpPathName, lpSecurityAttributes);
}
```

................你也可以通过代理 `LoadLibrary` 功能来抛出曲线球：

```c
HMODULE ProxyWorkItemLoadLibraryW(_In_ LPCWSTR lpModuleName)
{
    NTWAITFORSINGLEOBJECT NtWaitForSingleObject = NULL;
    RTLQUEUEWORKITEM RtlQueueWorkItem = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER Timeout = { 0 };

    NtWaitForSingleObject = (NTWAITFORSINGLEOBJECT)GetProcAddressA((DWORD64)GetModuleHandleEx2W(L"ntdll.dll"), "NtWaitForSingleObject");
    RtlQueueWorkItem = (RTLQUEUEWORKITEM)GetProcAddressA((DWORD64)GetModuleHandleEx2W(L"ntdll.dll"), "RtlQueueWorkItem");

    if (!NtWaitForSingleObject || !RtlQueueWorkItem)
        return NULL;

    if(RtlQueueWorkItem((PRTL_WORK_ITEM_ROUTINE)&LoadLibraryW, (PVOID)lpModuleName, WT_EXECUTEDEFAULT) != STATUS_SUCCESS)
        return NULL;

    Timeout.QuadPart = -500000;

    NtWaitForSingleObject(GetCurrentProcessNoForward(), FALSE, &Timeout);

    return GetModuleHandleEx2W(lpModuleName);
}
```

```c
HMODULE ProxyRegisterWaitLoadLibraryW(_In_ LPCWSTR lpModuleName)
{
    RTLREGISTERWAIT RtlRegisterWait = NULL;
    RTLDEREGISTERWAITEX RtlDeregisterWaitEx = NULL;
    NTWAITFORSINGLEOBJECT NtWaitForSingleObject = NULL;
    HANDLE WaitObject = NULL, EventObject = NULL;
    HMODULE hReturn = NULL;
    LARGE_INTEGER Timeout = { 0 };
    Timeout.QuadPart = 500;

    NtWaitForSingleObject = (NTWAITFORSINGLEOBJECT)GetProcAddressA((DWORD64)GetModuleHandleEx2W(L"ntdll.dll"), "NtWaitForSingleObject");
    RtlRegisterWait = (RTLREGISTERWAIT)GetProcAddressA((DWORD64)GetModuleHandleEx2W(L"ntdll.dll"), "RtlRegisterWait");
    RtlDeregisterWaitEx = (RTLDEREGISTERWAITEX)GetProcAddressA((DWORD64)GetModuleHandleEx2W(L"ntdll.dll"), "RtlDeregisterWaitEx");

    if (!RtlRegisterWait || !NtWaitForSingleObject || !RtlDeregisterWaitEx)
        goto EXIT_ROUTINE;

    EventObject = CreateEventW(NULL, FALSE, FALSE, NULL);
    if (EventObject == NULL)
        goto EXIT_ROUTINE;

    if (RtlRegisterWait(&WaitObject, EventObject, (WORKERCALLBACKFUNC)LoadLibraryW, (PVOID)lpModuleName, 0, WT_EXECUTEDEFAULT) != STATUS_SUCCESS)
        goto EXIT_ROUTINE;
    else
        NtWaitForSingleObject(EventObject, FALSE, &Timeout);

    hReturn = GetModuleHandleEx2W(lpModuleName);

EXIT_ROUTINE:

    if (EventObject)
        CloseHandle(EventObject);

    if(WaitObject)
        RtlDeregisterWaitEx(WaitObject, NULL);

    return hReturn;
}
```

---

#### 吐槽 4.

---

在代码中实现 `ZeroMemory` 时要小心。如果你尝试重写它，MSBUILD 会将其优化为 `memset` 并自动包含一些随机的东西。

所以，你必须写一些奇怪的 `ZeroMemory` 代码，比如这样：

```c
VOID ZeroMemory2(PVOID Destination, SIZE_T Size)
{
    PCHAR q = (PCHAR)Destination;
    PCHAR End = q + Size;
    
    for(;;)
    {
        if (q >= End) break; *q++ = 0;
        if (q >= End) break; *q++ = 0;
        if (q >= End) break; *q++ = 0;
        if (q >= End) break; *q++ = 0;
    }
    
    return;
}
```

-smelly







